# Docstrings generated by GitHub Copilot

from .aminoacid import Aminoacid
from operator import sub
import csv
from typing import Dict, List, Tuple, Optional, Union


class Protein:
    """
    Represents a protein and provides methods for folding and analyzing it.

    Attributes:
    - _sequence (str): The sequence of amino acids in the protein.
    - _list (List[Aminoacid]): The list of amino acids in the protein.
    - _grid (Dict[Tuple[int, int, int], Aminoacid]): The grid representation
        of the protein.
    - _head (Optional[Aminoacid]): The head amino acid of the protein.
    - _score (int): The stability score of the protein.

    Methods:
    - __init__(self, sequence: str) -> None: Initializes a new instance of the
        Protein class.
    - __create_double_linked_list(self) -> Optional[Aminoacid]: Creates a
        double linked list of amino acids.
    - get_score(self) -> int: Calculates and returns the stability score of
        the protein.
    - get_folding(self) -> List[Dict[str, Union[str, int]]]: Returns the
        folding information of the protein.
    - create_csv(self, filename: str, verbose: bool = False) -> None:
        Creates a CSV file with the folding information.
    - is_valid(self) -> bool: Checks if the protein is valid.
    - is_valid_fold(self, position: Tuple[int, int, int]) -> bool: Checks if a
        fold position is valid.
    - get_head(self) -> Optional[Aminoacid]: Returns the head amino acid of
        the protein.
    - get_tail(self) -> Optional[Aminoacid]: Returns the tail amino acid of
        the protein.
    - get_list(self) -> List[Aminoacid]: Returns the list of amino acids in
        the protein.
    - get_grid(self) -> Dict[Tuple[int, int, int], Aminoacid]: Returns the
        grid representation of the protein.
    - add_to_grid(self, position: Tuple[int, int, int], acid: Aminoacid) ->
        None: Adds an amino acid to the grid.
    - remove_from_grid(self, position: Tuple[int, int, int]) -> None: Removes
        an amino acid from the grid.
    - reset_grid(self) -> None: Resets the grid representation of the protein.
    - __str__(self) -> str: Returns the sequence of the protein.
    - __len__(self) -> int: Returns the length of the protein.
    - __getstate__(self) -> Tuple[str, List[Aminoacid],
        Dict[Tuple[int, int, int], Aminoacid], Optional[Aminoacid], int]:
        Returns the state of the protein for pickling.
    - __setstate__(self, state: Tuple[str, List[Aminoacid],
        Dict[Tuple[int, int, int], Aminoacid], Aminoacid, int]) -> None:
        Sets the state of the protein from pickling.
    """

    def __init__(self, sequence: str) -> None:
        """
        Initializes a new instance of the Protein class.

        Parameters:
        - sequence (str): The sequence of amino acids in the protein.
        """
        self._sequence: str = sequence
        self._list: List[Aminoacid] = []
        self._grid: Dict[Tuple[int, int, int], Aminoacid] = {}
        self._head: Optional[Aminoacid] = self.__create_double_linked_list()
        self._score: int = 0

    def __create_double_linked_list(self) -> Optional[Aminoacid]:
        """
        Creates a double linked list of amino acids.

        Returns:
        - Optional[Aminoacid]: The head amino acid of the protein.
        """
        if not self._sequence:
            return None

        # Create the first amino acid in the sequence
        head = Aminoacid(type=self._sequence[0])
        current = head
        self._list.append(current)

        # Create the rest of the amino acids in the sequence
        for _, amino_type in enumerate(self._sequence[1:], start=1):
            new_aminoacid = Aminoacid(
                type=amino_type, predecessor=current)
            current.link = new_aminoacid
            current = new_aminoacid
            self._list.append(current)

        return head

    def get_score(self) -> int:
        """
        Calculates and returns the stability score of the protein.

        Returns:
        - int: The stability score of the protein.
        """
        self._score = 0

        # Define the adjacent positions to the current amino acid
        adjacent_positions = [(1, 0, 0), (-1, 0, 0),
                              (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]

        for current in self._list:

            # Get the positions of the amino acids connected to the current
            # amino acid
            connections = [node.position for node in [current.predecessor,
                                                      current.link]
                           if node and node.position]

            # Check if the adjacent positions are not yet in the connections
            check_positions = [(c + adj[0], d + adj[1], e + adj[2]) for
                               (c, d, e), adj in zip([current.position] *
                                                     len(adjacent_positions),
                                                     adjacent_positions) if
                               (c + adj[0], d + adj[1], e + adj[2]) not in
                               connections]

            # Add the stability score of the current amino acid to the
            # total score
            for pos_tuple in check_positions:
                if pos_tuple in self._grid:
                    self._score += current.get_stability_score(
                        self._grid[pos_tuple])

        # Return the total score divided by 2 since every connection is
        # counted twice
        return (self._score // 2)

    def get_folding(self) -> List[Dict[str, Union[str, int]]]:
        """
        Returns the folding information of the protein.

        Returns:
        - List[Dict[str, Union[str, int]]]: The folding information of the
            protein.
        """
        folding: List[Dict[str, Union[str, int]]] = []
        current = self._head

        # Return empty list if the protein is empty
        if current is None or current.link is None:
            return folding

        # Get the folding information of the protein
        while current is not None:

            # Set the fold to 0 if the current amino acid is the last one
            if current.link is None:
                fold = 0

            # Calculate the fold based on the difference between the current
            # and next amino acid
            else:
                next_amino = current.link
                difference = tuple(
                    map(sub, next_amino.position, current.position))
                fold = difference[0] + 2 * difference[1] + 3 * difference[2]

            folding.append({'amino': current.get_type(), 'fold': fold})
            current = current.link

        return folding

    def create_csv(self, filename: str, verbose: bool = False) -> None:
        """
        Creates a CSV file with the folding information.

        Parameters:
        - filename (str): The name of the CSV file.
        - verbose (bool): Whether to print a message when the file is created.
        """
        # Create the CSV file
        with open(filename, 'w', newline='') as file:

            # Define the header and writer
            header = ["amino", "fold"]
            writer = csv.DictWriter(file, fieldnames=header)

            # Retrieve the folding information
            folding = self.get_folding()

            # Add the score to the folding information
            folding.append({'amino': 'score', 'fold': self.get_score()})

            # Write the folding information to the CSV file
            writer.writeheader()
            writer.writerows(folding)
            print(f"{filename} created.") if verbose else None

    def is_valid(self) -> bool:
        """
        Checks if the protein is valid.

        Returns:
        - bool: True if the protein is valid, False otherwise.
        """
        for index in range(len(self._list) - 1):
            for i in range(3):
                if abs(self._list[index].position[i] -
                       self._list[index + 1].position[i]) > 1:
                    return False

        # Check if every amino acid has a different position
        return len(self._grid) == len(self._sequence)

    def is_valid_fold(self, position: Tuple[int, int, int]) -> bool:
        """
        Checks if a fold position is valid.

        Parameters:
        - position (Tuple[int, int, int]): The position to check.

        Returns:
        - bool: True if the position is valid, False otherwise.
        """
        return position not in self._grid

    def get_head(self) -> Optional[Aminoacid]:
        """
        Returns the head amino acid of the protein.

        Returns:
        - Optional[Aminoacid]: The head amino acid of the protein.
        """
        return self._head

    def get_tail(self) -> Optional[Aminoacid]:
        """
        Returns the tail amino acid of the protein.

        Returns:
        - Optional[Aminoacid]: The tail amino acid of the protein.
        """
        if self._head is not None:
            current: Optional[Aminoacid] = self._head.link
            if current is not None:
                while current.link is not None:
                    current = current.link

        return current

    def get_list(self) -> List[Aminoacid]:
        """
        Returns the list of amino acids in the protein.

        Returns:
        - List[Aminoacid]: The list of amino acids in the protein.
        """
        return self._list

    def get_grid(self) -> Dict[Tuple[int, int, int], Aminoacid]:
        """
        Returns the grid representation of the protein.

        Returns:
        - Dict[Tuple[int, int, int], Aminoacid]: The grid representation of
        the protein.
        """
        return self._grid

    def add_to_grid(self, position: Tuple[int, int, int], acid: Aminoacid) -> \
            None:
        """
        Adds an amino acid to the grid.

        Parameters:
        - position (Tuple[int, int, int]): The position to add the amino acid.
        - acid (Aminoacid): The amino acid to add.
        """
        self._grid[position] = acid

    def remove_from_grid(self, position: Tuple[int, int, int]) -> None:
        """
        Removes an amino acid from the grid.

        Parameters:
        - position (Tuple[int, int, int]): The position to remove the amino
            acid from.
        """
        self._grid.pop(position, None)

    def reset_grid(self) -> None:
        """
        Resets the grid representation of the protein.
        """
        # Clear the grid
        self._grid.clear()

        # Add back all the positions of the amino acids
        current = self.get_head()
        while current:
            self._grid[current.position] = current
            current = current.link

    def __str__(self) -> str:
        """
        Returns the sequence of the protein.

        Returns:
        - str: The sequence of the protein.
        """
        return self._sequence

    def __len__(self) -> int:
        """
        Returns the length of the protein.

        Returns:
        - int: The length of the protein.
        """
        return len(self._sequence)

    def __getstate__(self) -> Tuple[str, List[Aminoacid],
                                    Dict[Tuple[int, int, int], Aminoacid],
                                    Optional[Aminoacid], int]:
        """
        Returns the state of the protein for pickling.

        Returns:
        - Tuple[str, List[Aminoacid], Dict[Tuple[int, int, int], Aminoacid],
            Optional[Aminoacid], int]: The state of the protein.
        """
        return (self._sequence, self._list, self._grid,
                self._head, self._score)

    def __setstate__(self, state: Tuple[str, List[Aminoacid],
                                        Dict[Tuple[int, int, int], Aminoacid],
                                        Aminoacid, int]) -> None:
        """
        Sets the state of the protein from pickling.

        Parameters:
        - state (Tuple[str, List[Aminoacid], Dict[Tuple[int, int, int],
            Aminoacid], Aminoacid, int]): The state of the protein.
        """
        self._sequence, self._list, self._grid, self._head, self._score = state
